# LeetCode

## hot100

### 哈希

1.两数之和（key--数组中的数字，value--索引）

```c++
// 一次遍历，与哈希表中的元素无法组成target时存入表中，与表中元素可以组成target时返回
```

49.字母异位词分组（字母异位词含有相同字母，因此排序后的字符串都相同，作为哈希表的key，value是存储所有异位词的数组）

```c++
// 字母异位词所含字母相同，故可将sort后的结果作为统一的判断标准
```

128.最长连续序列

```c++
// 使用unordered_set重新存储nums去重
// 遍历set中的所有元素，若num-1在集合中说明以num为起点记录序列长度可以覆盖这种情况，故跳过
// 否则以num为起点每次累加并判断累加结果是否在set中，记录连续累加的次数作为连续序列的长度
```

### 双指针

3.最长无重复子串

```c++
// 双指针，子串要求连续，用unordered_set维护一个不重复子串的元素
// 起始快慢指针都指向首元素，当set元素不重复时，移动快指针；当set元素重复时移动慢指针并擦除子串的首元素
// 记录子串中元素的个数
```

11.盛最多水的容器

```c++
// 双指针，一个指针指向首元素，一个指针指向尾元素，谁height小移动谁，两指针向中间移动
// 移动过程中存储最大面积
```

15.三数之和（排序+双指针)

```c++
// 双指针，先从小大大排序，第一层循环从前向后遍历，固定第一个数字，该数字之后为剩余数组
// 第一层循环前后数字相同时可跳过
// 剩下两个数字的选择就变成了两数之和问题，使用双指针解决
// 首指针指向剩余数组的首元素，尾指针指向剩余数组的尾元素，两指针向中间逼近
// 固定首指针，首指针前后指向的元素一致不改变搜索结果可跳过
// 尾指针从后往前移动，由于数组已排序，当三数和小于target时可停止尾指针的移动
```

283.移动零

```c++
// 双指针，慢指针指向第一个元素，快指针指向第二个元素，根据两指针指向元素是否为0的4种组合判断是否交换元素和移动指针
```

438.找到字符串中所有字母异位词

```c++
// 双指针，遍历输入字符串，按比较字符串长度取子串，若子串与比较字符串为字母异位词
// 应有sort之后的结果相等
// 当输入字符串的剩余长度不够取子串时停止遍历
```

### 前缀和

560.和为k的子数组

```c++
// 子数组是数组中元素的连续非空序列
// 前缀和，定义pre[i]为数组中0～i的元素之和
// 则对任意子数组j～i和为k可表示为，pre[i]-pre[j-1]=k，pre[j-1]=pre[i]-k
// 因此i遍历数组计算前缀和，并且查找遍历位置之前的前缀和为pre[i]-k出现的次数即为当前位置i处和为k的子数组数量
// 使用unordered_map维护，key为前缀和数值，value为该前缀和数值出现的次数
// 注意初始值map[0]=1，表示没有元素时前缀和为0，此时也要将0出现的次数1统计上
```

### 数组

56.合并区间

```c++
// 给定一系列区间，将有交集的区间合并
// 先按区间左端点的大小将输入区间数组进行升序排序
// 新建区间合并结果数组，初始时将输入的区间数组塞入结果数组
// 遍历排序后的区间数组，判断当前遍历的区间与结果数组中的最后一个区间是否存在交集，更新结果数组
```

189.轮转数组

```c++
// 将数组中的元素向右轮转k个位置
// 数组个数为n
// 将第一个数放到第k%n个数位置，将第k%n个数放到第2k%n个数的位置，以此类推
// 我们只需要一个temp存储每次赋值时原先的数值以用于下次赋值
// 轮转k次跳转时就会绕数组k圈，只需要判断下次跳转位置是否大于n-1即可，
// 满足绕数组k圈条件后退出while循环
```

238.除自身以外的数组的和

```c++
// 前后缀积+双指针，首指针计算前缀积，尾指针计算后缀积，
// 在结果数组中首尾指针的下一个位置计算与前缀积和后缀积的乘积
// 这样对于任意位置idx，首指针遍历到其前一个位置时idx处存储前缀积，尾指针遍历到其后一个位置时idx存储前缀积与后缀积的乘积
// 由此得到idx处除自身以外的数组和，可见首尾指针都需要遍历完整个数组
```

### 矩阵

4道



### 链表

2.两数相加

```c++
// while循环，直到最长的链表到达尾端为止，较短链表没有元素时按加0处理
// 每一次while循环里都是两链表中数字相加以及加上从低位进位的数字，同时更新carry作为下一次循环中的进位
// 记得在循环外面检查carry是否有值，需要增加链表后一位
```

19.删除链表的倒数第N个节点

```c++
// 写获取链表总长的函数，while循环实现，将倒数第N个变成正数第length-N+1个
// 遍历链表找到待删除节点的前一个pre，令pre的next指向pre的next的next即可删除指定节点
// 技巧，可以new一个哑节点其next指向head，从而避免对删除节点为首节点时的讨论，否则须增加if-else进行讨论，记得完成后delete掉该哑节点
```

21.合并两个有序链表

```c++
// 递归，递归函数输入待比较的两链表，比较两链表首元素的大小
// 令首元素小的链表的下一个指针指向首元素小的链表的下一个节点和首元素大的链表的首节点的合并结果(递归调用)
// 递归调用完成后首元素小的链表的首节点下一个就为下次合并的结果，因此返回首元素小的节点即可
// 递归终止条件为递归函数输入的两节点其中之一为空，中断合并，返回不为空的链表即可
```

23.合并k个升序链表

```c++
// 输入为vector<ListNode*> lists
// 在for循环外创建空链表ListNode *res = nullptr;
// 遍历输入链表数组中的每一个链表lists[i]
// 每次合并res与lists[i]，合并结果覆盖res，合并函数复用23题方法
// 最终结果就为res
```

24.两两交换链表中的节点

```c++
// 正常两两交换节点涉及三个指针的改变，分别是pre->next,cur->next,next->next
// 但对于第一二个节点交换时只涉及两个指针
// 为避免对第一二个节点交换时单独讨论，在head前创建哑节点dummy
// 直到哑节点后一个位置为空或者后后个位置为空退出循环
// 注意在最后销毁哑节点
// 为最终返回交换好的链表，哑节点的地址需要存储
// 创建局部变量pre，cur，next，在while循环中不断更新即可，最后返回dummy->next
```

25.k个一组翻转链表

```c++
// 递归，递归函数输入剩余链表head，内部对前k个节点进行翻转，翻转链表的方法同206题
// 递归调用时将前k个节点翻转后的尾节点，即当前递归函数输入的剩余链表的首节点head，
// head与下一次递归函数返回的下一组翻转的k个节点的首节点连接，这是关键
// 递归调用完成后，当前层函数返回值为前k节点翻转后的链表的首节点，返回pre
// 递归终止条件为剩余链表的节点个数小于k，直接返回head即可
```

138.随机链表的复制

```c++
// 所谓随机链表是指每个节点包含一个额外增加的随机指针 random
// ，该指针可以指向链表中的任何节点或空节点。 要求深拷贝一份随机链表
// 浅拷贝：仅复制指针值，不复制指针指向的内容
// 深拷贝：既复制指针值，又复制指针指向的内容
// 递归，递归过程中维护一个map，key为旧节点的地址，value为新节点的地址
// 从前往后遍历旧链表，若map没有记录，拷贝节点，在后继指针和随机指针的赋值时递归调用函数
// 函数返回值为新节点的地址
// 递归终止条件为待拷贝节点为空返回nullptr
```

141.环形链表

```c++
// 判断链表是否有环
// 双指针，快慢指针，快指针一次走两步，慢指针一次走一步，如果有环二者一定可以相遇
// 如果没环，fast一定先走到空指针
// 为保证在一开始就可以进入while循环
// 初始时刻使fast和slow岔开，slow指向首节点，fast指向次节点
```

142.环形链表2

```c++
// 找到入环的第一个节点
// 快慢指针，slow、fast同时从首节点出发，记首节点到入环节点的步长为a
// 入环节点到相遇节点的步长为b，相遇节点返回入环节点的步长为c
// fast笔slow多走一圈，slow走过步长为a+b
// fast走过步长为a+2b+c，又fast的走过的步长是slow的2倍
// a+2b+c = 2a+2b => a=c
// 另外取一个指针p，当slow、fast相遇时从首节点处开始移动，p与slow再次相遇时即在入环节点相遇
// 此时p指向的就为入环节点
```

148.排序链表

```c++
// 将输入链表排序
// 归并排序，递归，使用快慢指针将链表对半分，
// 快慢指针都从首节点出发，slow走一步，fast走两步，直到fast节点到达链表尾为止，
// 只有fast->next和fast->next->next都不为空时slow才移动，否则退出循环
// 链表若为偶数个元素slow指向中间位置的左边元素，链表若为奇数个元素slow指向中间元素，
// 递归调用，不断二分链表直到只剩一个一个节点递归终止
// 递归调用后对二分后的链表合并，合并方法同206题
```

160.相交链表

```c++
// 双指针，p1先遍历list1再遍历list2，p2先遍历list2再遍历list1
// while循环，p1==p2时退出循环
// 在第二轮遍历中两指针会同时指向相交节点(若存在的话)，或者同时指向list1和list2的末尾空指针(若不存在相交节点)
// 总之无论list1和list2是否相交，在第二轮遍历时p1和p2总会相等
// 循环退出后判断p1是否为非空，链表即为是否相交
```

206.反转链表

```c++
// 头插法，将原链表中的元素依次取出以头插的方式插入新链表中，
// 创建空指针pre作为反转后链表的末尾，创建cur和next，初始指向head和head->next
// while循环内部改变指向关系，cur下一个指向pre，然后更新pre、cur和next，
// 当cur为空时终止循环，反转后的链表的首节点即为pre
```

234.回文链表（链表递归可以实现从后往前遍历，结合从前往后遍历的指针，可以判断是否回文）

```c++
// 方法1
// 将链表复制到数组后再通过双指针判断
// 方法2
// 递归，递归函数可以找到链表最后一个有效节点，递归函数输入为首尾节点的地址，初始时都从head出发
// 先递归调用使尾节点到达链表末尾，然后判断首尾节点是否一致，首节点移动，尾节点通过递归函数出栈实现移动
// 维护一个标志位判断首尾节点是否一致，如果出现不一致不再进行判断
// 递归终止不是当首尾节点一致时退出，而是当尾节点到达末尾时退出，因为递归函数的作用是使尾节点到达末尾
```



### 栈

20.有效括号（栈+哈希表）

3道

### 二叉树

94.二叉树的中序遍历（递归，左子树->根结点->右子树）

101.对称二叉树（层序遍历，每层判断node_list的数值是否回文，nullptr用一个自定义的符号代替）

102.二叉树的层序遍历（BFS,遍历输入的node_list完成这一层节点的访问，每一层创建vector容器存储下一层需要访问的节点）

104.二叉树的最大深度（DFS）

108.将有序数组转换为二叉搜索树（数组等分，左半边是左子树，右半边是右子树，知道分完为止）

199.二叉树的右视图（层序遍历，每层的最后一个元素）

226.翻转二叉树（后序遍历，对当前节点操作是交换子节点次序）

230.二叉搜索树中第k小的元素（从1计数, 利用BST中序遍历是升序这一性质）

543.二叉树的直径（DFS，每层分别计算当前节点左右子树的最大深度，相加得到以该结点为根结点的二叉树直径，全局遍历记录最大直径）



### 二分法

33.搜索旋转排列数组

34.在排列数组中查找元素的第一个和最后一个位置



### 回溯

```c++
// 模板
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择 : 本层集合中的元素) {
        处理节点;
        backtracking(路径, 选择列表); // 递归
        撤销处理; // 回溯
    }
}
```

17.电话号码的字母组合（调用完递归函数后记得pop上一次循环填入的字母）

22.括号生成（每次递归注意“（”的个数小于给定生成括号的个数n，“）”个数小于“(”个数）

39.组合总和（只有在使用当前idx的数字时才在维护的combination数组中push元素，同时在回溯完成后要pop出来该元素，在验证idx+1元素时在下一次递归函数内去push/pop idx+1元素）

46.全排列（用unordered_set去重）

78.子集（于39思路一致，扫描输入数组的每一个元素，选择使用该元素填入维护的子集，或选择不使用，不填入直接扫描下一个数字，使用unordered_set去重）

79.单词搜索

```c++
// 多维回溯，从board的第ij位置出发，检查words从第k个位置之后的子串能否在board中找到
// 维护数组visited（与board同维度），在一次dfs中不能访问上一层已访问的位置，回溯之后可以将其复位，以便回溯之后的下一次dfs使用
```







### 动态规划

5.最长回文子串

```c++
// dp[i][j]表示从第i～j的元素构成的子串是否是回文子串
// 状态转移方程，dp[i][j]=dp[i+1][j-1] && str[i]==str[j]
// 先遍历长度，在遍历起始位置i，二者确定后j自然确定
// 注意边界条件L=1时dp[i][j]=1，L=2时dp[i][j]=str[i]==str[j]
// 注意j的越界判断
```



53.最大子数组和

```c++
// 动态规划，dp[i]表示以nums[i]为结尾的子数组最大和
// 递推公式，dp[i]=max{dp[i-1]+nums[i],nums[i]}
// 每一步比较将当前数字nums[i]作为前面子数组的结尾以及另起一个新的子数组哪个和大选哪个
```



62.不同路径

```c++
// 动态规划，dp[i][j]表示到达第i行第j列的路径个数
// 状态方程，dp[i][j]=dp[i-1][j]+dp[i][j-1]
```

64.最小路径和

```c++
// 动态规划，dp[i][j]表示到达第i行第j列位置的最小路径和
// 状态转移方程，dp[i][j]=min{dp[i][j-1],dp[i-1][j]} + grid[i][j]
```

70.爬楼梯

```c++
// 动态规划，dp[i]表示爬上第i级台阶有多少种方法
// 状态方程，dp[i]=dp[i-1]+dp[i-2];
```

198.打家劫舍

```c++
// dp[i]表示到达第i家最多抢到的钱数
// dp[i] = max{dp[i-2]+nums[i],dp[i-1]}
```

279.完全平方数

```c++
// dp[i]是整数i的完全平方数最少数量，加和i所需要的数j属于[1,sqrt(i)]
// 状态转移方程：dp[i] = 1 + min{dp[i-j^2]}，其中j从1遍历到<=sqrt(j)
// 完全背包
```

322.零钱兑换

```c++
// dp[j]表示满足总价值为j时的最少金币个数
// 完全背包问题
```





0-1背包问题

```c++
// 问题描述
// 给定N件物品和一个容量为W的背包。第i件物品的重量是w[i]，价值是v[i]。
// 每件物品只能选择放入或不放入背包（0-1，不能分割），
// 求在不超过背包容量的前提下，背包中物品的最大总价值。

// 解题
// 定义dp[i][j]：考虑前i件物品，在背包容量为j时能获得的最大价值
// 状态转移方程：
// 不选第i件物品：dp[i][j] = dp[i-1][j]
// 选第i件物品：dp[i][j] = dp[i-1][j-w[i-1]] + v[i-1] (需j≥w[i])
// dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1])
// 注意初始条件dp[0][j] = 0，dp[i][0] = 0，表示没有物品可选以及背包容量为0时价值为0
// 因此dp中的ij有没有物品和没有重量这一维度，而w、v中的索引i是从0开始，并不代表没有物品这一层
// 先遍历物品再遍历重量
```

完全背包问题

```c++
// 问题描述
// 给定N种物品和一个容量为W的背包。第i种物品的重量是w[i]，价值是v[i]。
// 每种物品可以选取无限次（区别于0-1背包），
// 求在不超过背包容量的前提下，背包中物品的最大总价值。

// 解题
// 定义dp[i][j]，表示前i中物品，在重量为j时获得到最大价值
// 状态转移方程
// dp[i][j] = max(dp[i][j], dp[i][j-w[i-1]] + v[i-1])
// 注意这里当选择第i种物品时dp[i][j-w[i-1]] + v[i-1]，与01背包不同
// 初始条件以及dp中的ij和wv中的i的区别同上
// 由于物品可以无限制选择，dp中i这个维度可以去掉(空间优化)，但还是需要遍历所有种类的物品
// 与01背包不同的是，先遍历重量，再遍历物品，即在每一个特定重量约束下遍历所有的种类取一个总价值最高的作为最终结果
```

多维背包问题

```c++
// 问题描述
// 给定N种物品和一个容量为V、最大承重为W的背包。各种物品数量不限
// 每件物品有体积v[i]、重量w[i]和价值c[i]，求在不超过背包体积和重量的情况下能装入物品的最大价值。

// 解题
// 定义dp[j][k]表示背包体积为j、重量为k时的最大价值
// 状态转移方程
// dp[j][k] = max(dp[j][k], dp[j-v[i-1]][k-w[i-1]] + c[i-1])
// 初始条件dp[0][k]=0、dp[j][0]=0
// 同样，最内层再遍历全部种类的物品
```



### 贪心

贪心算法的核心思想是：

1. **局部最优选择**：在每一步做出当时看起来最佳的选择
2. **不可回退**：一旦做出选择就不可更改
3. **希望导致全局最优**：通过一系列局部最优选择希望达到全局最优解

48.跳跃游戏二（）

55.跳跃游戏（遍历数组中的每一个元素，维护可到达的最远位置，超过数组长度时返回true）



### DFS

```c++
// 岛屿问题DFS基本框架
// 使用递归实现DFS
void DFS(vector<vector<int>> grid, int r, int c, vector<vector<int>> &visited){
    if(当前格子的坐标r、c不在grid中){
        return;
    }
    if(visited[r][c]==2){
        // 该格子已经访问过
        return；
    }

    // 将该格子标记为已访问
    visited[r][c] = 2;

    // 遍历上下左右四个格子
    DFS(grid, r+1, c, visited);
    DFS(grid, r-1, c, visited);
    DFS(grid, r, c+1, visited);
    DFS(grid, r, c-1, visited);
}

// 使用栈实现DFS
    int numIslands(vector<vector<char>>& grid) {
        int rows = grid.size();
        if (rows == 0) return 0;
        int cols = grid[0].size();
        
        int islands = 0;
        stack<pair<int, int>> st;
        
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (grid[r][c] == '1') {
                    islands++;
                    st.push({r, c});
                    
                    while (!st.empty()) {
                        auto [row, col] = st.top();
                        st.pop();
                        
                        if (row < 0 || row >= rows || col < 0 || col >= cols || 
                            grid[row][col] == '0') {
                            continue;
                        }
                        
                        grid[row][col] = '0';
                        
                        // 四个方向入栈
                        st.push({row - 1, col});
                        st.push({row + 1, col});
                        st.push({row, col - 1});
                        st.push({row, col + 1});
                    }
                }
            }
        }
        return islands;
    }
```

200.岛屿数量

```c++
// 以grid的任意一个格出发，若该格为1，进行DFS，在DFS过程中将1都置为0表示搜索到的格子同属一块陆地
// 遍历所有格子进行dfs，当当前格子为1时，陆地计数器加一，dfs会将与该格子同属一块陆地的格子都置为0
// 最终计数器的数量即为陆地的数量
```

417.太平洋大西洋水流问题

```c++
// DFS，问题问得是从哪个格子出发水流可以既流到太平洋又流到大西洋
// 反向搜索，分别从矩阵的四个边的某个格子出发，看看反向搜索到哪个格子，visited矩阵在该位置处置1
// 遍历四个边的每一个格子进行dfs，创建不同的visited矩阵表示可以流向大西洋和流向太平洋
// 最后遍历两个visited矩阵，如果大西洋visited矩阵和太平洋visited矩阵都为1，表示该位置满足题意
```

### BFS

```c++
// 上面岛屿问题也可以使用BFS实现
// 使用队列实现BFS
    int numIslands(vector<vector<char>>& grid) {
        int rows = grid.size();
        if (rows == 0) return 0;
        int cols = grid[0].size();
        
        int islands = 0;
        queue<pair<int, int>> q;
        
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (grid[r][c] == '1') {
                    islands++;
                    q.push({r, c});
                    
                    while (!q.empty()) {
                        auto [row, col] = q.front();
                        q.pop();
                        
                        if (row < 0 || row >= rows || col < 0 || col >= cols || 
                            grid[row][col] == '0') {
                            continue;
                        }
                        
                        grid[row][col] = '0';
                        
                        // 四个方向入队
                        q.push({row - 1, col});
                        q.push({row + 1, col});
                        q.push({row, col - 1});
                        q.push({row, col + 1});
                    }
                }
            }
        }
        return islands;
    }
```





### 纯理解题意

31.下一个排列

### 公司内部题库

1.给定一个二维数组，要求从右下角元素开始逆时针由外到内打印数组内元素（智驾大陆）

```c++
// 给定一个二维数组，要求从右下角元素开始逆时针由外到内打印数组内元素
// 边界控制:
// 维护四个边界: top, bottom, left, right
// 每完成一个方向的遍历后，收缩对应的边界
// 方向切换:
// 从右下角开始，初始方向为"上" (direction = 0)
// 移动顺序: 上 → 左 → 下 → 右 (循环)
// 终止条件:
// 当上下边界或左右边界交叉时结束循环

// while循环实现，当上下边界和左右边界都收缩到零时退出循环
// 循环外先确定打印初始位置为matrix右下角，循环内部先打印当期ij位置的元素，
// 再更新下一次打印的位置，通过switch判断遍历方向，在同一个方向里判断是否到达最后一个位置，如果到达需要更新遍历方向
```

2.手撕线段与多边形是否有交集判断函数
