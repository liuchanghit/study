# 问题数据bag查看

## JinnPlatform服务器bag访问

运行挂载命令，在本地bag_data文件夹中访问

```shell
sudo mount -t nfs -o ro,vers=3,proto=tcp,timeo=600 xsyd-hw-nas.leapmotor.com:/bag-data /home/lc_leap/bag_data/
```

## 28服务器bag访问

运行挂载命令，在本地28bag文件夹中访问

```shell
sudo mount -t nfs -o nolock 10.195.131.28:/data /home/lc_leap/28bag/
```

# 代码回灌

## nac代码回灌

由于脚本`pnc_build.sh`没有`x86_build_sim`参数，故需手动修改代码，用`x86_build`参数编译

`planning_params.pb.txt`文件修改以下值

```json
{
    run_env : 0
    data_replay_mode : 1
}

```

`version.h`修改以下值

```c++
#define _RELEASE_OR_SIM_PARAM_PNC_ 2
#define _RELEASE_OR_DEBUG_CODE_PNC_ 2
```

## spt代码回灌

检查x86_build_sim脚本是否修改以下代码

planning_params.pb.txt    run_env：0    data_replay_mode:  1

version.h    _RELEASE_OR_SIM_PARAM_PNC_ 2    _RELEASE_OR_DEBUG_CODE_PNC_ 2    _VISUALIZATION_PNC_ 2

其中_VISUALIZATION_PNC_ 2是创建foxglove可视化界面的开关

## cnap代码回灌Python脚本

planning_params.json文件修改`run_env：0`启动仿真模式

modules/planning/src/CMakeLists.txt修改`option(USE_MATH_SRC ON)`启动源码编译保证logsim仿真不卡顿

planning_core_lp.cpp打开`WorldModelContext::Instance()->set_enable_json(true);`的注释，Python脚本可以读到planning输出数据

在planning_tool仓库下运行命令

```shell
python3 leap_viz/lat_lon_motion.py -s ../data/log/logsim.out -o out.html
```



## 一些ros播包指令

### 启动plotjuggler

```shell
rosrun plotjuggler plotjuggler
```

### 启动rqt_bag

```shell
rosrun rqt_bag rqt_bag 2024_12_25_20_11_50.bag
```

### 播包所需输入topics

planning所需要的全部输入

```shell
rosbag play bag_name.bag -s 20 --topics /leap/adas/private/b/prediction /leap/adas/private/b/sdmap_odom /leap/adas/public/b/localization /leap/adas/public/b/perception/fusion /leap/hpc/public/b/chassis /leap/icu/public/b/manager/functions
```

-s 表示从特定时刻s开始    

-r 表示倍速播放

# 桌面文字消失

alt+F2  输入r，重新启动桌面

# pdp代码提交规范

[feat/fix/refactor/...]<PDP>: .......    feat新增功能；fix修复；refactor重构

# 速度规划代码注释

分支`spt-urp-speed-liuchang-1227`

文件夹`workspace/speed_annoation`

# 本地与服务器(工作站)之间的文件互传

```shell
#本地文件上传
scp /path/to/local/file c46186@10.192.156.11:/path/to/remote/directory
#服务器文件下载
scp c46186@10.192.156.11:/path/to/remote/directory  /path/to/local/file
scp -r    递归上传/下载
```

# LOGSIM使用

## docker操作

docker ps -a    显式全部容器

docker rm 容器名称    删除指定容器

## 播包

step1    进入10.192.156.11服务器远程桌面，在服务器中在logsim仓库文件夹中进入终端

step2    运行docker_run.sh脚本，当出现以下错误时，说明该容器名已经被使用，删除后重新运行脚本即可。进入docker容器后终端对话框变成如下

![](/home/lc_leap/图片/2025-02-06_10-39.png)

![](/home/lc_leap/图片/2025-02-06_10-42.png)

step3    容器内运行脚本update_dev_urp.sh，自行编译`LP_ADS_PNC`项目并将相关算法库copy至`LOGSIM`指定路径，后面可跟参数，具体用法看logsim仓库里的readme

step4    容器内运行脚本build.sh，编译logsim代码

step5    运行脚本run.sh，后跟bag包路径，播包，用法及参数同rosbag play，省去加topics









# 一些缩写

LB/RB——left boundary/right boundary道路左右边界

LC/RC——道路中心线？<mark>todo</mark>

HFSM——hierarchical Finite state machine分层有限状态机，状态机库文件hfsm2/machine.hpp提供

osp——open space planning

pipeline——管道，是一种将多个处理步骤串联起来的方式，数据通过这些步骤一次流动，每个步骤对数据进行特定操作，最终输出结果

facade——外观，是一种设计模式，属于结构型模式。它通过提供一个简化的接口，隐藏系统的复杂性，使客户端更容易使用

POI(point of interest)——兴趣点

odom(odometry)——里程计，坐标系是t0时刻车辆坐标系作为静系

# C++使用tips

## 指针常量和常量指针

```c++
// 指针常量(pointer to constant)，常量指针(constant pointer)

// 非指针类型常量可以赋值给普通非指针类型
// 将a的值"拷贝"给b，并不涉及更改a内存上的值，因此可以
const int a = 10;
int b = a;    // 正确

// pointer to constant不能赋值给普通指针
// 由于p2可以修改其指向的对象，此时常量a有被更改的风险，因此不允许赋值
const int* p1 = &a;
int* p2 = p1;    // 错误

// constant pointer可以赋值给普通指针
int *const p3 = new T();
int *p4 = p3;    // 正确
```



## 打印log时显示文件名和行号

预定义宏`_FILE_`和`_LINE_`，直接使用即可，不用定义，编译器会自动替代

常出错的点

判断相等用“==”

## 使用`std::move`相比于赋值操作的好处

`std::move(object)`用于将对象转换为纯右值，告诉编译器可以“移动”资源，而不是复制资源

移动语义 vs 复制语义

- 复制语义
  - 复制对象时，会创建一个新的对象，并将原对象的内容复制到新对象中。
  - 对于资源密集型对象（如动态数组、文件句柄等），复制操作可能非常昂贵。
- 移动语义
  - 移动对象时，资源的所有权从原对象转移到新对象，原对象被置为有效但未定义的状态。
  - 移动操作通常比复制操作更高效，因为它避免了资源的深拷贝。

## 头文件cmath和algorithm的区别

使用时都须加命名空间std::

选择 `<algorithm>` 当需要**操作容器数据**（排序、查找、变换等）

选择 `<cmath>` 当需要**数学计算**（三角函数、指数、对数等）

```c++
#include<cmath>

void main(){
    std::fabs(a);                                            //浮点取绝对值
    std::fmod(10.5，3.2);                        //浮点取余数
    std::fmin(a,b);                                        //浮点取小，min(a,b)

    std::pow(a,n);                                    //a的n次方，n可以是任何实数，n=0.5表示a的平方根
    std::sqrt(a);                                        //a的平方根

    std::sin(a);
    std::cos(a);

    std::exp(2);                                            //e^2
    std::log(10);                                            //自然对数，以e为底
}
```

```c++
#include<algorithm>

void main(){
    auto lamda = [](const T &a, const T &b){return a>b;}
    std::sort(container.begin(), container.end(), lamda);                //排序函数，默认升序，传入待排序的容器的起止迭代器，将排好序的元素重新放回container中。通过第三参数的lamda表达式实现自定义排序，上面实现的是降序
}
```

## 头文件iterator

```c++
#include<iterator>

auto dist = std::distance(it1,it2);            //计算两迭代器it1、it2之间的距离，要求it1的位置在it2之前或重合
```

## 明确区分函数入参是只读/可写的几种方法

```c++
//1.使用const明确标识只读参数，编译器检查，强制性
//只读参数：使用 const T& 或 const T*
//可写参数：使用 T& 或 T*
//其中const T&可为左值或右值，T&只能为左值

void Funtion(const std::vector<int> &data, int *min_result, int *max_result);

//2. 使用命名约定强化可读性，非强制性

//3.使用返回值而非输出参数，不适用于多结果输出的情况
```

## 常用STL容器

顺序容器/关联容器



## 内存分区中的栈/堆与数据结构中的栈/堆之间的关联

栈

内存分区中的栈和数据结构中的栈都遵循LIFO(后进先出)的原则

| 特性        | 内存栈 (Memory Stack) | 数据结构栈 (Stack Data Structure) |
|:--------- |:------------------ |:---------------------------- |
| **所属领域**  | 计算机内存管理机制          | 抽象数据类型(ADT)                  |
| **物理/逻辑** | 物理内存区域             | 逻辑数据结构                       |
| **主要用途**  | 函数调用、局部变量存储        | 数据临时存储、特定算法实现                |
| **实现方式**  | 由CPU和操作系统管理        | 可用数组或链表实现                    |
| **生长方向**  | 向底地址增长（通常）         | 逻辑结构，无方向                     |

堆

内存分区中的堆和数据结构的堆**完全没联系**，在计算机动态内存分配机制中，内存的申请和释放是随机的，导致内存空间的使用呈现堆积的状态，因此在内存分区中称为堆

| 特性       | 内存堆                    | 数据结构堆                  |
|:-------- |:---------------------- |:---------------------- |
| **本质**   | 动态内存区域                 | 完全二叉树结构                |
| **用途**   | 动态内存分配                 | 高效获取最大/最小值             |
| **管理方式** | 由内存管理器自动管理             | 程序员显式维护堆性质             |
| **操作**   | malloc/free/new/delete | insert/remove/heapify等 |
| **生长方向** | 向高地址增长（通常）             | 逻辑结构，无方向               |



## friend关键字

```c++
class MyClass {
    //...
    private:
    friend Class ClassName;
}
```

友元类可以访问当前类的所有成员，包括 private 和 protected 成员。

## explicit关键字

explicit关键字要求用户只能通过调用构造函数的方式完成构造，禁止通过“=”进行隐式构造

对于有多个入参的构造函数，隐式构造是通过`{}`实现

```c++ 
class Foo {
public:
    Foo(int a, double b) { /* ... */ }
};

Foo f = {1, 2.0}; // OK，隐式构造
```

## 构造函数

- 类内部的成员在构造函数体开始时，所有成员变量的内存都已经分配，只是还未初始化

```c++
class MyClass{
    public：
        class(){
            //构造函数走到这里时，&vec、&ptr都是有效地址，只是还没有初始化，可以安全的获取地址
            vec = std::vector<int>(2,3);	//初始化vec,{3,3}
            // 注意在这里ptr是nullptr(这是由于预设了默认值)，但是&ptr不是nullptr，这是由于构造函数执行时会提前对成员变量分配内存。ptr是一个空指针，但是存储这个空指针的内存是有效内存
            ptr = &vec;		//初始化ptr
        }
    private:
    std::vector<int> vec;
    std::vector<int> *ptr = nullptr;
}
```

- 默认构造函数``MyClass() = default;``会自动调用成员的无参构造函数完成成员的构造
- 构造函数使用列表初始化的好处，避免调用成员的默认初始化函数造成不必要的开销

```c++
class MemberClass {
public:
    MemberClass() { 
        std::cout << "MemberClass默认构造函数被调用" << std::endl; 
    }
    MemberClass(int x) { 
        std::cout << "MemberClass有参构造函数被调用" << std::endl; 
    }
};

class Container {
public:
    // 如果不写列表初始化，会调用MemberClass的默认构造函数
    Container(int x) {
        // 这里MemberClass的默认构造函数已经被调用了
        member_ = MemberClass(x);  // 创建临时对象并赋值
    }
    
    // 推荐做法：直接调用MemberClass的有参构造函数
    Container(int x) : member_(x) {
        // MemberClass的有参构造函数被调用
    }
    
private:
    MemberClass member_;  // 这是成员对象
};
```



# VScode使用

使用说明书在[Visual Studio Code 文档](https://code.visualstudio.com/docs)

## 配置环境

配置编译器和调试器，不同操作系统使用的编译器不相同，配置步骤在上面的说明文档

**Linux**：GCC(GNU Compiler Collection，GNU是一个操作系统但现在系统内核未开发成功，目前最大的成果是编译器集合，目前业内流通的Linux操作系统是“GNU的软件+Linux的内核”合体而成)，包含gcc(专门编译C)和g++(专门编译C++)

**Windows**：mingw(Minimalist GNU for Windows)，GCC在windows系统的移植版

## Setting中的选项

### 代码美化

在Settings中设置

```c++
"editor.formatOnSave": true    //保存时自动美化代码
"editor.defaultFormatter": "ms-vscode.cpptools"    //默认美化器使用C\C++自带美化器
```

如果对格式有更高级的要求，下载插件clang-format

高级操作todo

### 显示一个/多个打开的文件

settings中搜索`show tabs`选择`"single"或者"multiple"`

如果想要显示的多个文件堆叠显示，搜索`workbench.editor.waptabs`勾选即可



## 好用的插件

**C\C++ Extension Pack**	C\C++语言开发工具包，包含C/C++和C/C++ Themes

**Doxygen Documentation Generator**	生成函数注释

**Copilot**	代码AI工具，支持问答及代码联想

**proto3**	支持proto文件中变量的索引，同索引函数声明和定义

**GitLens**	可以看到每行代码的提交commit

**Dev Containers**	可以将IDE的文本环境连接到本机docker环境，安装好后在IDE界面的左下角使用attach to running container，或者Ctrl+Shift+P使用命令面板搜索。在容器内的IDE有可能不识别本地的一些插件，需要将这些插件在容器内重新安装一遍

![image-20250910150221689](/home/hb35341/.config/Typora/typora-user-images/image-20250910150221689.png)





# Shell命令

## 安装命令

```bash
# 安装deb文件
sudo dpkg -i 文件名.deb
```

## 远程操作

```bash
scp user@remote_host:/remote/path/file.txt /local/path/		# 从远程服务器复制文件到本地
scp -r user@remote_host:/remote/path/ /local/path/			# 从远程服务器复制文件夹到本地

```

## export / echo

```bash
# export 命令用于设置环境变量，让变量在当前shell及其子进程中可用
# echo 命令是bash中最常用的输出命令，用于在终端显示文本
```

## $符

```bash
# 变量引用: $var 或 ${var}，推荐后者
# 命令替换: $(command)
# 例子，获取当前时间
current_dir=$(pwd)	# 执行pwd命令，并获取返回值
echo "Current directory: ${current_dir}"	# 读取变量current_dir的值
```

# Protoc

编译proto文件

```bash
# 先清除已有的pb.*文件
rm planning_internal.pb.*
# 在proto文件位置处生成pb.*文件，由于proto中的import指令是在modules层级下，因此要在modules上一层级运行下述指令
protoc --cpp_out=. ./modules/planning/proto/planning_internal.proto
```



# Docker

## 安装

https://juejin.cn/post/7447180053975302180

## 常用指令

```bash
docker ps -a 	# 显示全部容器，去掉参数-a只显示运行中的容器
docker images	# 显示全部镜像

# 重命名已有容器
docker rename <旧容器名或ID> <新容器名>


# 删除单个容器
docker rm <容器名或ID>
# 强制删除（会先停止容器再删除）
docker rm -f <容器名或ID>


# 删除指定镜像
docker rmi <镜像名或ID>
# 强制删除（即使有容器在使用）
docker rmi -f <镜像名或ID>


# 两个命令组合可以重新挂载目录
docker commit current_container my-new-image:version	# 将当前容器保存为镜像

# 创建并运行一个新的容器
## 基本结构
docker run -it [参数] [镜像名] [命令]
## 实例
docker run -it --name planning_pyqt_ws_new_interface --net=host --privileged=true \
	-v /tmp/.X11-unix:/tmp/.X11-unix \
	-v $HOME/.Xauthority:/root/.Xauthority  -e DISPLAY=$DISPLAY \
	-v ~/workspace/pnc_pyqt_tool:/pnc_pyqt_tool \
	-v ~/workspace/bag:/ros2data \
	-v ~/workspace/hiluo_planning_new_interface/planning_ros:/src/apal_plan/planning_ros \
	-v ~/workspace/map:/ws_worldmodel/hdmap \
	pyqt_image:v1.1 bash
## 解析
### X11 图形显示支持
# 挂载 X11 套接字和认证文件，使容器内可以显示图形界面
# 让容器能够使用宿主机的图形显示
-v /tmp/.X11-unix:/tmp/.X11-unix
-v $HOME/.Xauthority:/root/.Xauthority
-e DISPLAY=$DISPLAY
### 工作空间挂载
# 将宿主机的多个工作目录挂载到容器内
# 实现宿主机和容器之间的文件共享
-v ~/workspace/pnc_pyqt_tool:/pnc_pyqt_tool
-v ~/workspace/bag:/ros2data
-v ~/workspace/hiluo_planning_new_interface/planning_ros:/src/apal_plan/planning_ros
-v ~/workspace/map:/ws_worldmodel/hdmap
### 网络和权限
--net=host			# 使用宿主机网络，容器直接使用宿主机的网络接口
--privileged=true	# 给予容器特权模式，可以访问所有设备
### 容器配置
--name				# 为容器指定名称
pyqt_image:v1.1		# 使用的镜像名和标签
bash				# 容器启动后执行的命令
```



# Git

## 安装

```bash
# 更新包列表
sudo apt update
# 安装 git
sudo apt install git
# 验证安装
git --version
```

## 概念

暂存区：git add后将修改添加到暂存区

工作目录：文件修改并保存后，将修改添加到工作目录

子模块(submodule)：是一种将一个Git仓库嵌套在另一个Git仓库中的机制

## git log

```bash
# 不用切换分支，在当前分支上查看另一个分支的提交历史
git log --oneline other_branch_name
```



## git checkout

```bash
# 基于指定分支创建新分支
# 不加指定分支默认基于当前分支创建
# Git的推送逻辑：
# 如果远程仓库没有同名分支：创建新的远程分支
# 如果远程仓库有同名分支：推送到现有分支
git checkout -b feature/new-feature origin/main
```

## git branch

```bash
# 设置本地分支跟踪正确的远端分支
git branch --set-upstream-to=origin/correct_branch local_branch

# 删除分支
git branch -D deleted_branch
```



## git reset

用于重置当前分支的状态，**取消提交(commit)**

三种模式：

`git reset --soft`仅重置 `HEAD` 指针，不修改暂存区和工作目录。

`git reset --mixed`(默认）重置 `HEAD` 指针和暂存区，但不修改工作目录。

`git reset --hard重置 `HEAD` 指针、暂存区和工作目录。

## git restore

用于恢复文件状态，恢复工作区和暂存区

```bash
#主要选项
--staged      # 恢复暂存区
--worktree    # 恢复工作区
--source      # 指定恢复源
--quiet       # 静默模式
--progress    # 显示进度
--force       # 强制恢复

#什么选项都不加，恢复工作区的单个文件到HEAD状态
git restore
```



## git cherry-pick

用于合并指定提交到当前分支，这些提交可以是其他分支上的

```bash
# 合并单个提交
git cherry-pick <commit-hash>

# 合并多个提交
git cherry-pick <commit1> <commit2> <commit3>

# 合并连续的提交范围
git cherry-pick <start-commit>..<end-commit>

# 合并连续提交范围（包含起始提交）
git cherry-pick <start-commit>^..<end-commit>
```



## git rebase

用于 **重新整理提交历史**。它可以将一个分支的提交“移动”到另一个分支的最新提交之后，从而使提交历史更加线性化。

假设你有一个 `feature` 分支，基于 `main` 分支开发。在开发过程中，`main` 分支有新的提交，你希望将 `feature` 分支的提交基于最新的 `main` 分支重新应用：

```bash
git checkout feature
git rebase main
```

## git push

```bash
git push origin HEAD:remote-branch	#将本地最新提交推送到远端分支
origin            # 远程仓库名称
HEAD              # 本地当前分支的引用
:                 # 分隔符
remote-branch     # 远程分支名称
```



## git config

```bash
git config user.name your_name		# 修改用户名
git config user.email yout_email	# 修改用户邮箱
git config core.fileMode false		# 忽略权限修改导致检索出的文件修改
```



# ROS/Cyber RT分布式通信架构

## 名词

```markdown
消息（Message）

- 定义：消息是数据的载体，通常是一个结构化的数据包（如protobuf、json、结构体等）。

- 作用：用于在不同模块之间传递信息，比如一帧图像、一个定位结果、一组障碍物等。

话题（Topic）

- 定义：话题是消息的分类标签，用来标识一类消息的“主题”或“类别”。

- 作用：不同模块通过订阅/发布同一个话题，实现数据共享和解耦通信。

通道（Channel）

- 定义：通道是消息传递的“管道”或“路径”，本质上就是“话题”在底层实现时的载体。

- 作用：在 Apollo Cyber RT 中，通道和话题几乎等价，都是指消息传递的路径。模块通过通道收发消息。
```

消息是“内容”，话题/通道是“分类和传递的路径”。
话题更偏向于“语义上的分类”，通道更偏向于“技术实现上的数据流路径”。
在 Apollo Cyber RT 里，话题和通道通常可以互换使用，但“消息”永远是被传递的数据本身。

## Publisher-Subscriber通信

广播式发布消息，若节点需要订阅消息A，需要从消息A发布的通道中订阅，即订阅的通道要跟发布的通道一直才能实现消息的传递

## Client-Server通信

服务端从客户端拿到请求是从通道中拿topic，客户端获取服务端的响应是从请求发送函数的返回值中获取，而不是通过通道中的topic获取

## ros指令

```bash
# 包操作
## 录包
ros2 bag record /your_topics(-a 表示录所有topic) -o /your_path/

## 播包

```

```bash
# topic操作
## 显示topic列表
ros2 topic list

# 显示对应topic的内容
ros2 topic echo /your_topic_name
# 配合grep显示topic特定范围的字段
ros2 topic echo /map/map | grep lanes -A 9
# -A显示匹配行及其后N行
# -B显示匹配行及其前N行
# -C显示匹配行及其前后N行

```



# Ubuntu好用的软件

**draw.io** 用于画流程图、示意图、类图

**typora** markdown编辑器

**Terminator终端终结者** 用于多屏显示终端

**flameshot** 截图工具

**XTerminal** 用于图形化界面显示远程ssh电脑的工具

**glogg** 用于查看日志文件

# Markdown语法

## 标题

```markdown
# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
```

## 强调

```markdown
*斜体* 或 _斜体_
**粗体** 或 __粗体__
***粗斜体*** 或 ___粗斜体___
或者ctrl+B
```

## 代码

行内代码

```markdown
使用 `print()` 函数。
```

代码块

```markdown
```c++
int main(){
    std::cout << "hello world!" << std::endl;
}
```

快速退出代码块

​    在代码块中使用Ctrl+Enter即可退出代码块

分割线

```markdown
---
```



## 列表

无序列表，连续两次回车即可中断列表

```markdown
- 项目 1                //注意是有空格的
- 项目 2
  - 子项目 2.1    // tab
  - 子项目 2.2
```

有序列表，连续两次回车即可中断列表

```markdown
1. 项目 1                //注意是有空格的
2. 项目 2
   1. 子项目 2.1
   2. 子项目 2.2 
```

## 引用

连续两次回车即可中断引用

```markdown
> 这是一个引用。
>> 这是一个嵌套引用。
```

# todo

MCTS

KD-tree

python bokeh库用于画图？